---
title: "Hello"
date: 2022-01-11T16:20:17+08:00
draft: false
---

# 深入浅出Redis

>redis是当前最流行的非关系型数据库，很多场景都可以使用到redis。
###为什么使用redis？
在项目中，很多场景的并发量很大，如秒杀之类，若不使用redis缓存直接让其访问数据库，那么会对数据库造成很大的压力从而导致数据库崩了，因此引入redis做分布式缓存
redis的五种数据结构：
一：String类型 keyValue都是String （可以用作缓存）
二：List类型 Value可存放多个值，有序且重复（可以通过lpush，rpop实现队列 也可以通过range范围查询来实现分页功能，用户最近视频观看记录）
三：Set类型 无序但不可重复（因为可以自动去重因此可以实现并集交集差集，可以实现好友去重，可以实现抽奖活动，去重保证每个人参加一次，可以实现朋友圈点赞）
四：Zset类型 对应的每个set元素可添加一个分数（可以实现排行榜）zset的底层是用跳表（一个多层的有序链表，一种基于概率统计的插入算法）实现
五：Hash类型 value就是一个map类型（购物车）,redis的Hash其实可以理解成JAVA中的MAP

###redis的持久化技术：
因为redis是在内存中工作，一旦关闭所有数据就消失了，因此需要使用一种持久化的技术，将redis的数据保存起来
RDB和AOF
RDB：持久化时会fork一个一模一样的子进程进行持久化，因为redis是单线程如果用当前的工作线程进行持久化，那么就会阻塞用户的操作直到持久化完成。在调用save命令时会阻塞当前的redis（RDB主要负责全量持久化），Redis适用于容灾恢复支持大数据量恢复，但其可能会造成数据的丢失（Redis意外down掉的话，会丢失最后一次快照的修改）
AOF：可以支持实时的持久化，AOF文件通常比RDB大恢复起来慢（AOF主要负责增量持久化）,但其可以保证数据的完整性
RDB和AOF的选择问题：
当对数据很敏感且不允许分钟内的数据丢失则使用AOF，若数据量较大且追求恢复速度使用RDB，RDB非常适合灾难恢复，不过还是建议两个持久化策略一起使用。开机启动时，先查看是否开启了AOF，如果开启则加载AOF的Appendonly.aof，没开启则加载RDB的dump.rdb对于主从同步来说，从库启动后先执行RDB实现全量同步，再执行AOF进行实时持久化
redis的事务：
redis也支持事务，只不过他的事务和mysql的不同，他的是谁成功就是成功，失败就是失败，即使失败了也不会让其他成功的回滚
###redis常见的问题：
####redis的雪崩问题：
当redis当中很多字段都同时失效时，大量的请求直接打进了mysql当中，造成了redis的雪崩。
解决方法：
①可以设置他们的失效期均匀分布
②在程序中设置限流降级操作
③如果是因为redis宕机问题，则可以设置redis集群保证高可用④数据预热，在活动开始前提前将数据存入redis当中。
####redis的缓存穿透：
用户恶意访问mysql中不存在的数据，故redis也没有因此会造成大量的请求打到mysql中。
解决方式：
一：redis添加空数据：在数据库中查不到数据时，自定义一个类存到redis中，每次查询redis后，instanceof 自定义的class，如果为True则说明是空数据，直接返回查不到，不再去查询mysql
二：访问mysql前添加布隆过滤器，现将mysql中的数据id存储到布隆过滤器，布隆过滤器中以0，1的方式存放mysql中的数据，当判断数据是否存在布隆过滤器时，它会对给定的元素进行Hash计算如果结果都为1则数据在布隆过滤器中，如果有一个为0则数据不存在布隆过滤器中，直接返回不再让它执行后面的代码（布隆过滤器也是有误差的，布隆过滤器中存在的数据mysql不一定存在，布隆过滤器中不存在的数据mysql一定不存在）框架的布隆过滤器只适合于单机版，我们可以使用redis的bitmap实现分布式布隆过滤器
####redis的缓存击穿：
当多个用户访问某一个热点数据，该数据在redis中突然失效，此时大量的请求又会打到mysql当中。
解决方法：
一：添加锁，只允许一个线程去访问mysql，访问完mysql将数据重新添加到缓存后，再让其他线程访问缓存
二：设置热点数据永不过期
redis的主从复制：
复制一份一模一样的redis，实现读写分离高可用，主库负责写，从库负责读
原理：
从库（slave）监听主库（master）：Slaveof （主库的）ip 端口从库启动后连接到master后会发送一个psync命令，如果该从库是第一次连接主库，则master接到命令后会触发一个全量复制，启动后台的存盘进程，收集所有的修改命令，生成RDB快照，然后将RDB传送给从库，从库完成全量同步。之后新增到master的数据可以使用AOF增量同步到从库
redis的哨兵模式：
当主库挂了之后，从库通过投票的方式选出一个从库来转为主库(最少要有3个哨兵实例)
配置方式：主库新建一个sentinel.conf文件，编写 sentinel monitor 自定义名 本机io 端口 x：x表示主机挂掉之后，从机的投票数的满足条件
哨兵的作用：
①：集群监控：负责监控Redis master和slave是否正常工作
②：消息通知：当某个Redis实例发生故障时，发送消息作为报警通知给管理员
③：故障转移：如果master节点挂了，那么在slave节点中自动选取一个作为新的master
④：配置中心：如果故障转移发生了，则会通知其他slave新的master地址
如何在redis中找出key是以某个固定前缀开头的数据？
可以采用keys指令来扫描指定前缀的key。
若当前redis正在线上使用，调用keys指令时，由于redis是单线程的故会阻塞一段时间直到keys指令执行完毕，这时可以使用scan命令，可无阻塞的进行扫描指定前缀的key，但scan执行时间比keys长。
redis为什么快？
因为他的操作是基于内存的
且采用了io多路复用技术
它是单线程避免了多线程环境下不必要的上下文切换（多线程下Cpu为每个线程分配一个时间片，时间片结束重新进入就绪状态，会让其他线程执行）也不必担心锁的问题，也不会出现死锁情况
io多路复用：
redis当中利用了select poll epoll可以同时监听多个流的IO事件能力，在空闲时，他会把线程阻塞掉，当一个或多个流有IO事件发生时，就会从阻塞状态中唤醒，程序会轮询一次所有的流，按顺序处理就绪的流，此时就可以避免大量的无用操作。
多路：多个网络连接 复用：复用同一线程 采用io多路复用可以让单个线程高效的处理多个连接请求
redis的过期策略:（存放的数据设置过期时间后如何在到达时间后移除数据）当数据达到过期时间后，不会第一时间删除，它的过期策略是惰性删除（取数据时，判断一下是否过期，过了就删除），定时删除（每隔一段时间，随机取一些数据判断是否过期，过期就删除）
redis的淘汰策略：（当内存满了，需要淘汰一些数据）
FIFO：淘汰最早添加进来的数据 LRU：淘汰最近最少使用的数据 random：随机淘汰
为什么使用redis不使用Memcache
一：因为MC的Key不能超过250字节Value不能超过1M字节
二：key的最大失效时间为30天
三：MC不支持持久化和主从同步
四：redis支持更多的数据结构（MC只支持String类型），redis采用单线程模式处理请求（MC是多线程），因此可以采用非阻塞的异步处理机制，单线程还可以避免线程上下文切换浪费的时间
####redis的线程模型：
redis所采用的线程模型是文件事件处理器，文件事件处理器是单线程的，所以redis也是单线程的，它采用io多路复用来同时监听多个Socket
如何保证数据库和redis的数据一致性：
（如果先删缓存，再更新数据库，则有可能出现，更新数据库前又读取数据，缓存中又存放的是更新前的数据）
（如果先更新数据库，再删缓存，有可能出现更新数据库成功，删除缓存失败，数据不一致）
①：采用延迟双删：
一：删除缓存中的数据
二：更新数据库中的数据
三：根据业务情况，睡眠一定时间（害怕出现：读取操作在更新数据库前，当执行完第四步，才将读取的数据存入到redis，这时就造成了数据不一致，因此需要等待读取所需时间后再删除）
四：再删除缓存中的数据（若在更新前，又进行读取，读取到的是更新前的脏数据，确保缓存中存放的不是之前的数据）
②：采用消息队列：
先更新数据库再删除redis
如果redis删除失败：

一：在catch中将删除失败的key发送到消息队列
二：自己接受消息
三：获取要删除的key后，进行重试删除操作直至删除成功
③：设置缓存的过期时间：这样无论如何最终过期后都会去mysql中读取最新的数据
如何保证Redis的并发竞争key问题：
所谓Redis的并发竞争key问题，就是多个服务同时对一个key进行操作，但最终执行的顺序和我们预期的顺序不同,这就导致了不同的结果
解决方法：通过分布式锁可以解决这个问题

使用Hash存储商品数据，当数据量很大时，如何进行优化？
Hash的结构是：key filed value，当存储商品时，一般key设置为product，由于数据量很大，对同一key进行操作会有阻塞的情况。
分段存储：我们可以存储数据时，通过商品Id%10000获取值0-9999之间，然后存储时就可以：key：（product：10），filed：id，value：商品信息，这样就可以保证每个key下的商品数据量都不大
redis是单线程的，那我们现在的服务器都是多核的，是不是会有性能的浪费？
虽然他是单线程的，但我们可以在单机开多个Redis实例
如果单机还有瓶颈，那么也可以在多机下开启redis集群（cluster）
数据同步的时候断网了或者服务器挂了怎么办？
在网络恢复或者服务器恢复后，会自动把缺少的数据补上。

